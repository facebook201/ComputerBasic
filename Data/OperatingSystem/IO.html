<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>I/O | 计算机基础</title>
    <meta name="description" content="飘飘乎如遗世独立 羽化而登仙">
    <link rel="icon" href="/ComputerBasic/pkq.jpeg">
    
    <link rel="preload" href="/ComputerBasic/assets/css/0.styles.0aa3b252.css" as="style"><link rel="preload" href="/ComputerBasic/assets/js/app.765a49f3.js" as="script"><link rel="preload" href="/ComputerBasic/assets/js/14.fd608719.js" as="script"><link rel="prefetch" href="/ComputerBasic/assets/js/10.5e913407.js"><link rel="prefetch" href="/ComputerBasic/assets/js/11.957959ba.js"><link rel="prefetch" href="/ComputerBasic/assets/js/12.03920d5d.js"><link rel="prefetch" href="/ComputerBasic/assets/js/13.1252f78d.js"><link rel="prefetch" href="/ComputerBasic/assets/js/15.8eee1f56.js"><link rel="prefetch" href="/ComputerBasic/assets/js/16.c0e4a8da.js"><link rel="prefetch" href="/ComputerBasic/assets/js/17.98bb84b7.js"><link rel="prefetch" href="/ComputerBasic/assets/js/18.4609d0ea.js"><link rel="prefetch" href="/ComputerBasic/assets/js/2.6b100f8d.js"><link rel="prefetch" href="/ComputerBasic/assets/js/3.cae2b930.js"><link rel="prefetch" href="/ComputerBasic/assets/js/4.5043f531.js"><link rel="prefetch" href="/ComputerBasic/assets/js/5.787030ac.js"><link rel="prefetch" href="/ComputerBasic/assets/js/6.90dcc7d3.js"><link rel="prefetch" href="/ComputerBasic/assets/js/7.3cccda54.js"><link rel="prefetch" href="/ComputerBasic/assets/js/8.d170b27a.js"><link rel="prefetch" href="/ComputerBasic/assets/js/9.551475a1.js">
    <link rel="stylesheet" href="/ComputerBasic/assets/css/0.styles.0aa3b252.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ComputerBasic/" class="home-link router-link-active"><!----> <span class="site-name">计算机基础</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/DataBase/Redis/" class="nav-link">Redis</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">操作系统</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/OperatingSystem/" class="nav-link router-link-active">操作系统</a></li><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/C/" class="nav-link">C</a></li><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/Go/" class="nav-link">Go</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机网络</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/ComputerNetwork/" class="nav-link">计算机网络</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">原理好文</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/Article/" class="nav-link">原理好文</a></li></ul></div></div> <a href="https://github.com/facebook201/ComputerBasic" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/DataBase/Redis/" class="nav-link">Redis</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">操作系统</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/OperatingSystem/" class="nav-link router-link-active">操作系统</a></li><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/C/" class="nav-link">C</a></li><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/Go/" class="nav-link">Go</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机网络</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/ComputerNetwork/" class="nav-link">计算机网络</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">原理好文</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ComputerBasic/Data/Article/" class="nav-link">原理好文</a></li></ul></div></div> <a href="https://github.com/facebook201/ComputerBasic" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav> <div class="load-success"><div id="codefund"></div></div> <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>操作系统</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/ComputerBasic/Data/OperatingSystem/Compositionprinciple.html" class="sidebar-link">操作系统 OperatingSystem</a></li><li><a href="/ComputerBasic/Data/OperatingSystem/Compile.html" class="sidebar-link">组成原理核心</a></li><li><a href="/ComputerBasic/Data/OperatingSystem/" class="sidebar-link">操作系统</a></li><li><a href="/ComputerBasic/Data/OperatingSystem/Process.html" class="sidebar-link">进程</a></li><li><a href="/ComputerBasic/Data/OperatingSystem/IO.html" class="active sidebar-link">I/O</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ComputerBasic/Data/OperatingSystem/IO.html#多路复用" class="sidebar-link">多路复用</a></li><li class="sidebar-sub-header"><a href="/ComputerBasic/Data/OperatingSystem/IO.html#epoll的设计思路" class="sidebar-link">epoll的设计思路</a></li><li class="sidebar-sub-header"><a href="/ComputerBasic/Data/OperatingSystem/IO.html#epoll-lt-与-et模式的区别" class="sidebar-link">epoll LT 与 ET模式的区别</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="i-o"><a href="#i-o" class="header-anchor">#</a> I/O</h1> <p><strong>I/O 输入输出是操作系统里面很重要的一块，操作系统管理者设备命令的发送，捕捉中断，处理设备的错误。</strong></p> <h2 id="多路复用"><a href="#多路复用" class="header-anchor">#</a> 多路复用</h2> <blockquote><p><strong>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程</strong>。</p></blockquote> <p><img src="https://pic2.zhimg.com/80/18d8525aceddb840ea4c131002716221_1440w.jpg" alt="border"></p> <h3 id="io-多路复用的出现"><a href="#io-多路复用的出现" class="header-anchor">#</a> IO 多路复用的出现</h3> <p>最早的时候，没有多路复用 使用的 BIO、NIO的实现 但是都有一些问题。</p> <h4 id="同步阻塞（bio）"><a href="#同步阻塞（bio）" class="header-anchor">#</a> 同步阻塞（BIO）</h4> <ul><li><p>服务端采用 单线程，当接受一个请求后，在 recv或send调用阻塞时。将无法接收上一个请求（必须要等完成）无法处理并发。</p></li> <li><p>服务端采用多线程，当接受一个请求后，开启线程进行recv，可以完成并发处理。但是请求数量增加，大量的线程占用很大的内存空间。切换线程会带来很大的开销。</p></li> <li><p><strong>多线程有个问题就是 CPU上下文切换 需要处理操作句柄。代价高</strong></p></li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>// 单线程伪代码描述
while<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  // accept阻塞
  client_fd <span class="token operator">=</span> accept<span class="token punctuation">(</span>listen_fd<span class="token punctuation">)</span>
  fds.append<span class="token punctuation">(</span>client_fd<span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>fd <span class="token keyword">in</span> fds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    // recv阻塞（会影响上面的accept）
    <span class="token keyword">if</span> <span class="token punctuation">(</span>recv<span class="token punctuation">(</span>fd<span class="token punctuation">))</span> <span class="token punctuation">{</span>
      // logic
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>


// 多线程伪代码描述
while<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  // accept阻塞
  client_fd <span class="token operator">=</span> accept<span class="token punctuation">(</span>listen_fd<span class="token punctuation">)</span>
  // 开启线程read数据（fd增多导致线程数增多）
  new Thread <span class="token function-name function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    // recv阻塞（多线程不影响上面的accept）
    <span class="token keyword">if</span> <span class="token punctuation">(</span>recv<span class="token punctuation">(</span>fd<span class="token punctuation">))</span> <span class="token punctuation">{</span>
      // logic
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre></div><h3 id="同步非阻塞-（nio）"><a href="#同步非阻塞-（nio）" class="header-anchor">#</a> 同步非阻塞 （NIO）</h3> <ul><li>服务器接受一个请求，加入fds集合，每次轮询一遍fds集合recv（非阻塞）数据。每次数据则立即 返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu。</li></ul> <h3 id="io多路复用"><a href="#io多路复用" class="header-anchor">#</a> IO多路复用</h3> <p>服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历有事件的fd进行accept/recv/send，使其能<code>支持更多的并发连接请求</code></p> <p><strong>通过内核获取有读写事件发生的fd（文件描述符），只要有一个则返回，无则阻塞，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，accept/recv是不会阻塞</strong></p> <h3 id="多路复用的方式"><a href="#多路复用的方式" class="header-anchor">#</a> 多路复用的方式</h3> <ul><li><p>select</p> <ul><li>单个进程所打开的FD是有限制的，通过FD_SETSIZE设置，默认1024</li> <li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li> <li>对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）</li></ul></li> <li><p>poll</p> <ul><li><p>poll与select相比，只是没有fd的限制，其它基本一样</p></li> <li><p>缺点</p> <ul><li>每次调用poll，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li> <li>对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）</li></ul></li></ul></li> <li><p>epoll （只能在  linux下工作）</p></li></ul> <h2 id="epoll的设计思路"><a href="#epoll的设计思路" class="header-anchor">#</a> <strong>epoll的设计思路</strong></h2> <p>epoll是在select出现N多年后才被发明的，是select和poll的增强版本。epoll通过以下一些措施来改进效率。</p> <p><strong>措施一：功能分离</strong></p> <p>select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。如下图所示，每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket相对固定，并不需要每次都修改。epoll将这两个操作分开，先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程。显而易见的，效率就能得到提升。</p> <p><img src="https://pic2.zhimg.com/v2-5ce040484bbe61df5b484730c4cf56cd_b.jpg" alt="border"></p> <p>先用epoll_create创建一个epoll对象epfd，再通过epoll_ctl将需要监视的socket添加到epfd中，最后调用epoll_wait等待数据。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token function">bind</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token function">listen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>

<span class="token keyword">int</span> epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将所有需要监听的socket添加到epfd中</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>接收到数据的socket<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//处理</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>select低效的另一个原因在于程序不知道哪些socket收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的socket，就能避免遍历。如下图所示，计算机共有三个socket，收到数据的sock2和sock3被rdlist（就绪列表）所引用。当进程被唤醒后，只要获取rdlist的内容，就能够知道哪些socket收到数据。</p> <h2 id="epoll-lt-与-et模式的区别"><a href="#epoll-lt-与-et模式的区别" class="header-anchor">#</a> <strong>epoll LT 与 ET模式的区别</strong></h2> <ul><li>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。</li> <li>LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作</li> <li>ET模式下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，或者遇到EAGAIN错误</li></ul> <h4 id="epoll-的应用"><a href="#epoll-的应用" class="header-anchor">#</a> Epoll 的应用</h4> <ul><li>redis</li> <li>nginx</li></ul> <p><img src="https://pic3.zhimg.com/v2-5061e5d3791e31a62a394b0b5ce1c986_b.jpg" alt="border"></p> <h3 id="网卡接收器"><a href="#网卡接收器" class="header-anchor">#</a> 网卡接收器</h3> <p>网卡接收网线传输的数据，经过硬件电路传输，通过DMA控制器传输、IO通路选择等，然后网卡把收到的数据写入内存。</p> <h3 id="进程阻塞为什么不占用cpu资源"><a href="#进程阻塞为什么不占用cpu资源" class="header-anchor">#</a> 进程阻塞为什么不占用CPU资源</h3> <p>阻塞是进程调度关键的一环节，它是指进程在等待某事件发生之前的等待状态，recv、select、epoll 都是阻塞方法。比如recv方法接收数据，recv是一个阻塞方法，当程序运行到recv时，它会一直等待，直到接收数据才往下执行。阻塞的原理是什么？</p> <h3 id="工作队列"><a href="#工作队列" class="header-anchor">#</a> 工作队列</h3> <p>操作系统为了支持多任务，实现了进程调度的功能，运行状态是进程获得CPU的使用权，等待状态就是阻塞状态，比如上述程序运行到recv时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p> <h3 id="内核接收网络数据过程"><a href="#内核接收网络数据过程" class="header-anchor">#</a> 内核接收网络数据过程</h3> <p>借用图一张</p> <p><img src="https://pic2.zhimg.com/80/v2-b7b2427e96fb520dcfd3e94af4fc9e0d_720w.jpg" alt="border"></p> <h3 id="问题？"><a href="#问题？" class="header-anchor">#</a> 问题？</h3> <ul><li><p>操作系统如何知道网络数据对应哪个socket？</p> <p><strong>scoket 对应一个端口号，而网络数据包中包含了IP和端口号信息，内核可以通过端口号找到对应的scoket，为了提高处理速度，操作系统会维护端口号到socket的索引结构，以快速读取。</strong></p></li> <li><p>如何同时监视多个socket的数据？</p> <p><strong>多路复用</strong></p></li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//  epoll 实现</span>
  <span class="token comment">// 第一步 创建epfd 白板</span>
  <span class="token keyword">int</span> epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// static struct  epoll_event ev;</span>
    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">'round again!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    nfds <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> events<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nfds<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAXBUF<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">read</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> MAXBUF<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">puts</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
</code></pre></div><ul><li><p>1、调用 epoll_create() 创建一个 epoll对象（在epoll文件系统中为这个句柄对象分配资源）</p></li> <li><p>2、调用 epoll_ctl() 向epoll对象中添加或删除fd与对应的事件信息（每次只要传入一个fd）</p></li> <li><p>3、调用 epoll_wait() 阻塞等待内核返回的可读写事件，收集发生的事件的连接，无需遍历所有集合。</p></li></ul></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/facebook201/ComputerBasic/edit/master/docs/Data/OperatingSystem/IO.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/ComputerBasic/Data/OperatingSystem/Process.html" class="prev">
          进程
        </a></span> <!----></p></div> </div></div></div>
    <script src="/ComputerBasic/assets/js/app.765a49f3.js" defer></script><script src="/ComputerBasic/assets/js/14.fd608719.js" defer></script>
  </body>
</html>
