# 操作系统 

>  **操作系统的下面内容主要来自清华大学的理论知识课件、以及其他地方的资料自己总结而来的。**



::: tip 为什么学操作系统

* **打基础**

  比如说，做一个网络代理软件，不过是从socket上收一个包然后转发给另一个socket而已，这好像和操作系统没多大关系吧？但真做了，你会发现，用一个线程处理网络IO，只要写对了，那么哪怕系统压力很大，只要CPU顶得住，就可以保证引入的延迟总是在几个毫秒之内；但如果用了多线程分别处理收/发，那么只要网络压力稍大，引入的延迟就会增加，很快额外延迟就可能突破几十个毫秒（这实际上已经完全不能用了）。

  **想搞明白这是为什么，对操作系统调度原理、时间片等概念没有足够深刻的理解，是不可能的。**

  

* 完全不懂何谓文件系统、何谓目录树的用户

* 操作系统作为一种特殊的软件，其在任务调度（多线程、并发），文件管理等等问题的解决方案和思路是典范性的。操作系统对各种数据结构的设计和发明有促进作用，其在各种数据结构使用上也是典范性的。

* 大白话说，操作系统是由众多巨老以非常牛逼的方法去实现的已被证明非常稳定的软件。跟那些屎山代码工程完全不在一个宇宙。



**曾经有个北大大佬说，学好这些基础。你能通过他们分析解决你99%的现实问题。**

:::



## 什么是操作系统？

简单来说 操作系统也是一个软件。它是管理下层硬件，为上层软件提供统一的、容易理解的抽象API的软件。



* 操作系统是一个控制程序
* 是一个资源管理器
  * 应用程序与硬件之间的中间层
  * 管理各种计算机软硬件资源
  * 提供访问计算机软硬件资源的高效手段
  * 解决资源访问冲突、确保资源公平使用



### 操作系统的地位

![border](https://raw.githubusercontent.com/facebook201/ComputerBasic/master/docs/img/operatingsystem/op1.png)

操作系统是对计算机硬件进行一层隔离，对上层应用提供常见逻辑的一些资源。

![border](https://raw.githubusercontent.com/facebook201/ComputerBasic/master/docs/img/operatingsystem/op2.png)


### ucore操作系统的内核

![border](https://raw.githubusercontent.com/facebook201/ComputerBasic/master/docs/img/operatingsystem/os.png);


### 操作系统内核特征

* 并发
  * 计算机系统中同时存在多个运行的程序、需要OS管理和调度资源
* 共享
  * 同时访问
  * 互斥共享 内存访问的时候 怎么管理
* 虚拟
  * 利用躲到程序设计技术、让每个用户都觉得有一个计算机在为他服务
* 异步
  * 程序的执行不是一贯到底、而是走走停停，向前推进的速度不可预知
  * 只要运行环境相同 OS需要保证程序运行的结果也要相同 相同的输入有相同的输出



## 为什么学习操作系统

* 学习操作系统有挑战 
* 操作系统很有用处 熟悉工作原理
* 操作系统更好的帮助你工作

> * 它是计算机系统的基本组成部分
> * 硬件的发展和应用需求所驱动 就像 windows 有那么多版本的操作系统是一个概念
> * 学术和工业的持续推进



## 计算机体系结构

（CPU = 运算器 + 控制器）

* 运算器
* 控制器
* 存储器  （内存）
* 输入设备
* 输出设备

运算器和控制器单元集成在CPU中实现，存储器的容量不断扩大、输入输出设备不断更新，这些部件构成了当代计算机硬件系统的基本组成。

![border](https://pic2.zhimg.com/v2-92fdb4030ccc4cc1aacda3dd200291c9_r.jpg)



### CPU

* 寄存器 是CPU组成部分，用来暂存指令、数据和地址。一般一个CPU 有 20 ~ 100  个寄存器
* 控制器 负责内存上的指令。数据读入寄存器，根据指令的结果控制计算机
* 运算器 负责运算从内存中读入寄存器的数据
* 时钟 负责发出CPU 开始计时的时钟信号



### **总线**

总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：

- *地址总线*，用于指定 CPU 将要操作的内存地址；
- *数据总线*，用于读写内存的数据；
- *控制总线*，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；

当 CPU 要读写内存数据的时候，一般需要通过两个总线：

- 首先要通过「地址总线」来指定内存的地址；
- 再通过「数据总线」来传输数据



## 指令和状态

* 指令
  * 特权指令：操作系统内核部分使用，用户不能使用。（I/O, 清内存，设置时钟等）
  * 非特权指令 ：

> 注意：**为了限制应用程序的行为，必须在应用程序和操作系统执行时有不同的状态，核心问题在于保护关键寄存器和重要的物理内存。且记住下面的两种状态都是CPU的两种状态之一，所以一般是从一种状态切换到另一种状态。**

* 状态 PSW 状态标识
  * 用户态：用户态：执行非特权指令
  * 核心态 ：执行全部指令 **CPU的特权模式**
  * 核心态 —> 到用户态**是执行一个特权指令。将程序状态字(PSW)标志位设置为用户态。**

**用户态和核心态之间的切换通过中断实现（且是唯一途径），使得操作系统获得计算机的控制权。从而让操作系统开展管理工作（进程的切换，分配I/O设备）、[ 有了中断 才能实现多道程序并发执行]**



## 中断

计算机管理的设备很多，管理起来也复杂。**所以 外设输入的不确定性，处理器需要一种机制，当外部有输入请求时需要立即处理这种请求。**

> 比如当你键盘输入某个字时，这时候键盘设备会发出一个电信号，中断控制器接收到之后，会去请求CPU，是否有其他的中断程序，如果没有CPU会通过中断来打断执行的任务，暂时挂起当前在执行的任务，把目前的数据保存起来，然后跳转执行中断处理的函数，执行完毕之后会把刚才执行的任务数据恢复 继续执行。

### 中断分类

（1）、外部中断

CPU以外的中断信号，也叫做硬件中断。实际上，计时器是多线程的基石之一（我们在后边的多线程实现章节会讲到），但是计时器是以中断为基础的，所以，**多线程是靠中断来驱动的。**

（2）、内部中断

CPU执行代码引起的中断。

* 软中断： 软中断是程序主动发起的中断，**这种中断大多数是为了实现程序的一些实时的系统功能需求**
* 异常： 异常中断是程序被动发起的中断，并且会产生错误的结果导致CPU无法继续执行指令。



> 再举两个例子区分软中断与异常，当用户需要立即知道计算机运行的时间时，可以通过使用time函数来获取，实际上，time函数中触发了一个定义好的软中断，这个软中断通知CPU打断执行接下来的代码，并且获取内核中记录的时间信息，最后返回到用户代码中。这个过程，是程序主动发出的中断，所以是软中断。当CPU遇到类似100除以0这样的代码时，由于这样的写法是错误的，所以会触发异常中断产生（程序被动产生的中断）。



**只要发生了中断，操作系统就会介入，开展管理工作。**



## 系统调用

**系统调用是操作系统为用户提供的一系列API；系统调用将用户的请求发给内核，内核执行完以后，将结果返回给用户；系统调用组成了用户态和内核态交互的基本接口。**

> **凡是与资源有关的操作（存储分配、I/O 操作，文件管理）都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。保证稳定性和安全性，防止用户非法操作。**



### 分类

* 进程
* 文件管理
* 设备
* 信息 （CPU、操作系统信息）
* 通信

### 库函数

**库函数**就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现。它对系统调用进行封装，提供简单的基本接口给用户，这样增强了程序的灵活性，当然对于简单的接口，也可以直接使用系统调用访问资源，例如：**open（），write（），read（）**等等。注意open是系统调用，fopen是库函数 对 open进行了封装，简化操作。



### Shell

shell就是外壳的意思。就好像把内核包裹起来的外壳。它是一种特殊的应用程序，俗称命令行。为了方便用户和系统交互，一般一个shell对应一个终端，呈现给用户交互窗口。当然shell也是编程的，它有标准的shell语法，符合其语法的文本叫**shell脚本**。很多人都会用shell脚本实现一些常用的功能，可以提高工作效率。



## 用户态 内核态

用户态和内核态其实是相对应的。出现的目的是为了保护操作系统，防止系统中的重要数据被修改和破坏。**最大的区别就是权限不同**

> **内核态：执行特权指令，访问所有寄存器内容以及内存区域。**
>
> **用户态：相对于内核态，只能执行特定的指令，如果需要执行特殊操作，需要通过系统调用，切换到内核态执行操作。用户态到内核态的切换是中断实现的，且是唯一途径**

**当用户程序需要操作系统服务而而调用系统调用的时候，处理机应该从用户态转到核心态，当系统调用返回用户程序的时候，处理机的状态从核心态回到用户态。**



### 用户态到内核态的切换

**我们的系统资源是固定的，所以都是操作系统负责调度分配我们的资源。不同的操作给不同的权限。**



### 切换的三种方式

* 系统调用

  其实本质就是中断，只不过有软中断和硬中断。比如读写文件、申请内存。**C库接口malloc申请动态内存，malloc的实现内部最终还是会调用brk（）或者mmap（）系统调用来分配内存。**

* 外设中断

  外设完成用户请求，向CPU发送中断信息

* 异常

  如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常（内存管理部分）。





## 并行和并发

1、并发是一个物理CPU在若干程序之间多路复用。并发性是对有限物理资源强制行使多用户共享以提高效率。**关键是你有处理多个任务的能力，不一定要同时**

​	![border](https://pic2.zhimg.com/80/5a0c72f510595a240e7de0644e65fd59_1440w.jpg)

2、并行是两个或两个以上的活动在同一时刻发生。并行性使多个程序同一时刻可在不同CPU上同时执行。每个CPU执行一个任务**关键是你有同时处理多个任务的能力。**

​	![border](https://pic2.zhimg.com/80/ebc6b9ce334985dc3f6d906a06579ead_1440w.jpg)



### 功能分类

* **文件管理：完成设备的 请求/释放/启动等**
* **设备管理:  完成文件的 读、写、创建、删除等**
* **进程管理: 进程的 创建、撤销、阻塞、唤醒等**
* **进程控制: 进程之间的 消息传递、信号传递等**
* **内存管理: 内存的 分配、回收等**









